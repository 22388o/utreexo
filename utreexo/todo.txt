sending and receiving block proofs

There's a bunch of way this can be done.

"client" means utreexo node doing IBD
"server" means archive node with all the proofs and blocks


3 basic categories

-----
P Easiest!  Send the full block proof every time.  Sure, but huge.

Q Send no proof, but send indexes for all inputs.  Let the client node figure out what it doesn't have, and request what it needs.  Then the server sends what's requested, the client's happy, and proceeds to the next block.

R Send exactly what the client needs.  The server needs to keep track of what the client has, what it needs, and send the right thing for each block.
-----

I think Q seems the way to go for now.  P is basically already written as there's nothing to write.  But P uses way too much bandwidth, and throws away all the improvements.

R seems hard; maybe can't work on it's own.  Q and R can be mixed; there can be a server which anticipates what the client needs, and sends that, but it might send too much or too little.  If it sends too much that's no big deal, just ignore it.  If it doesn't send enough then you'll need the code from R to request what was left out.  It seems that the R method will get out of sync easily; if the client shuts down or restarts, their memory can be wiped and they'll have to start populating their forest again.  Also if a client downloads from multiple servers at the same time (which is something you really want to support) then R seems to not stay in sync without some other messaging.

The downside of Q is the extra round trip.  So latency.  But does latency really matter?  This is IBD; you can pipeline things.  Except you can't really pipeline this huh, because you don't know what you'll need for the blocks 5 blocks forward.  Pipelining / parallel validation is cool but it actually uses more data, but can really speed things up.

So don't worry too much about the round trip; it adds some time but oh well.  There's 2 ways I can think of for Q:

Give a list of target indexes, and return a list of indexes.  Simplest, but the problem is... what if only 1 thing is spent, and you don't have a proof for it, but you have a proof for something right near it.  Then you get back a whole branch when you only needed a hash or two.

Give a list of target indexes, then return a list of indexes and heights.  So for each, give me the proof of this up to h high.  That can get a bit redundant, in that some of the heigts are obvious; if I need a proof for both 2 and 3, whatever the proof height I need for 2 is, the height for 3 will be 0.  But... it's a byte.  1 byte per requested utxo is no big deal, at worst a couple KB per block of upload from the client to the server.

Ways to repot a subset -- there are several!

Given a []uint32 with len 100, you want to send a subset back.  The sender still has the slice.

Easy: just send the subset, as a slice.  This is inefficient, especially if it's a slice of, say, hashes.
Or: send a slice of positions (ints)  Should be smaller; the ints you send back only need as many bits as the set is large.
Or: send a slice of the gaps between positions in your subset.  Could be smaller?  Especially if there's clustering?
Or: send a bitmap.  1 bit for every element of the set.

I think when the subset's around half of the initial set, the bitmap is probably the best you can do.  If it's all uniform and random.  If the subset is either really sparse or really dense, then sending the subset (or inverse) is more efficient.  What's the crossover point..?  I dunno!  There have got to be papers about this.  It seems like a thing in computer science.

-----
UNrelated (?) idea: have the bridge / archive nodes give utreexo roots stuck to every block.  They send the "this is the roots it should result in" message as well.  Scary?, but lets you do arbitrarily parralel validation.

For example, block 7 comes with:
block itself
roots from block 6
proofs for block 7
end result roots for block 7.

Then... you can download any block, verify the whole thing in isolation and mark it as "consistent" -- you don't know if it's right, but you know that *if* the roots from 6 are right then the roots for 7 are right.  Then you can just do arbitrary IBD all over the place.

-----


ok so the paper's out, but actually, there's lots of modifications to do here before it can be ported over to be used

- forest / pollard

does forest make sense?  Get rid of it?
bad: shuffles can be very i/o heavy.  height adjusts are also i/o heavy, but hardly ever happen.  big shuffles can sometimes happen though.
good: easy to make it disk based rather than ram based.  forest in ram probably doesn't make sense.  not sure.  But much easier to have as a on-disk blob as you just seek to index*32 to get the data you want.

pollard forgetting:

lots of changes here.  Having a uint64 slice for forgets is not the way to do it; then you need to descend for each of them at the end.  There's also the problem of siblings of targets.

There's also a big problem with siblings and remembering.  When you add a leaf, and flag it as "memorable" (because it will be deleted soon), we'll call that a "target".  You have, well, 4 options.  Remember the target, the sibling, both, or none.  None means you have no caching.  Target only acutally isn't great because you don't have the sibling.  If it's sibling or both, that works but here's the problem: what do you do with the sibling once the target's gone?  In other words, why did you store that sibling?  Was it just to prove the target?  In that case, the target's gone, and you can forget about the sibling.  But maybe the sibling was there because it, too, will be deleted soon, in which case it should stick around.

So having a memorable flag that persists and moves around with a leaf is a good idea.  Then you know, hey, this thing is memorable; wherever it moves, remember it's sibling.  However, if you have leaves where neither is memorable, you can prune them.

forgetting terms:

n: total leaves (utxos)
m: stored leaves
p: number of leaves to forget this block

Currently time of p * log(n); decend for each.

If you have to go through all the leaves to see which are forgettable, that's no good, because that goes through all existing leaves.  That'd be time of O(m).  


If you make forgettable into a slice of pointers that still doesn't help; you can't go "up" from the pointer.

really we want O(p) forgetting.  I think you can get this; have a slice of pointers, but the pointers are to the parents of the things to forget.  Then the nodes all shuffle around but the pointers don't have to change which is nice.


dirtymap: really there just shouldn't be any maps.  the dirty map can probably be made into a sorted slice.  Maybe can get rid of entirely.
