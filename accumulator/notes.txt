Problems with hash to known:

You can't JUST hash to known.  That's not enough.  Example:

28
|---------------\
24              25*             26
|-------\       |-------\       |-------\
16      17*     18      19      20      21      22
|---\   |---\   |---\   |---\   |---\   |---\   |---\
00  01* 02  03  04d 05d 06d 07d 08  09  10  11  12  13  14

A proof for 00 is already known: 01, 17, 25.  04, 05, 06, 07 are deleted.
The proof for this deletion is just 24.  If you only hash to known, you'll hash to find 18 and 19, then hash those to get 25 and see that it's a match.  So you're done, right?
No... because you haven't populated 24.  And when the deletion happens, 26 moves to 25, and then you'll need 24 to compute the new 28.
Also you can't just populate 24 without hashing up to 28, because what if the 24 they give you as a proof is wrong?  Then you'd have a bad accumulator state.

It seems like you can never populate without matching above it.  That makes sense; you need to verify every hash you're populating in to the forest.
If 24 was already present then you could skip the populate and hash steps.



You get a slice of targets.  They're in order.  You've also got a pollard with at least the roots.
You need to ingest the targets & proofs.  All the targets and all the proofs need to be in the pollard at the end of the ingestion, because those hashes need to be there for the Modify() call

so we have 2 phases: blaze and matchPop

blaze builds trails down to the target leaves.  It would be faster to not start at the root each time, and branch off instead, but that can be optimized later, not a big deal.  Following pointers is pretty quick.

As it builds empty nodes down to the targets, it also builds a slice of pointers to those nodes.  The pointers should match up right to the proof items.  So the proof verification step is just two slices of equal length: one of node pointers, and one of hashes from the proof.  Then you can just go through and matchPop each.

Of course it's not that simple since you also have to hash if you populated, or flag parents as skippable if you matched.

For now, keep matching all hashes in the proof.  We're *hashing* to known, but we receive the whole proof and check the whole thing, so eve if there are proofs we don't need as that data is already in the pollard, we will fail the ingest.


------

change how ProofPositions works, maybe simpler.  Up to the root first, then on to the next target.
for example


30
|-------------------------------\
28                              29
|---------------\               |---------------\
24              25              26              27
|-------\       |-------\       |-------\       |-------\
16      17      18      19      20      21      22      23
|---\   |---\   |---\   |---\   |---\   |---\   |---\   |---\
00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15

targets are 03, 09, 11.  Instead of going row by row, go all the way up first.  proofs would be

02, 16, 25, 29  (done with proof for 03)
08, 21, 27  (done with proof for 09; intersects at 29)
12, 23  (done with proof for 11l intersects at 27)

This might be simpler.  ProofPositions and really just all the batchproof stuff is way to complicated and hard to understand.  I don't think this is even any slower.

This feels closer to how hashing to known should work; for each target we can decend to the leaf, keeping the whole branch down.  The proof will populate that branch.  Just need to keep track of what's been populated by the proof and what's already there.
Like the 08, 21, 27 proof branch; how to we know to stop at 27, and not go to 29?  Because 29 was already given.  But that's not as obvious as you go up the branch.  Just keep some kind of hash map based set?  That's kind of an ugly way to do it.  Keeping an extra bit on the polNode would do it, it seems.  Or just get a function that, given a list of targets, generates a list of proofs, and breaks them up in the way I just did there with the (done with proof for) parts.  That might not be so bad..?  There's got to be a bit flippy way to do that without maps.

Given a list of leaf positions, return an equal length list of heights to intersection.  So in this case 03, 09, 11 returns 4, 3, 2.

Also this is sub optimal because 29 shouldn't be in the proof.  Nor 27.  So pop off the proof when you intersect.  Anyway I can try this, maybe gives a simpler proof position sequence.

-----


Not quite there, but the basic design:

You start with a pollard, and a proof / target list.
What's important in the pollard is what's there and what's not.

Example:
start with a tree like this:

14
|---------------\
12              13
|-------\       |-------\
08      09      10      11
|---\   |---\   |---\   |---\
00  01  02  03  04  05  06  07

You have 12, 10, 6. (a proof for 7)
You get targets: 0, 1, 2
You get proof: 3, 13

You start at the root and start building a slice of nodes, top to bottom and left to right.

... really you get a list of targets, which means if you go through each target you go top to bottom each time, but... there's probably a way to only make one pass top to bottom. 
There might be a fun bit shifty way to do this; given a list of leaves, give a list of parents.  (deduped)  There might be something in the code for this already?  If not, maybe make it.

ok starting at the root and going down, build a list of node-pairs, and also a list of bools, which mean "target / target parent".  I'll put a * for those

[12* 13]
[8* 9*]
[0* 1*] [2* 3]

I think the bool list can be a separate bitmap, in this case 10111110.  (or 10; 11; 1110 for rows)
 Then go bottom to top.
Bottom row: * means match/pop with target, no * means match/pop with proof.
Upper rows: * means hash then match/pop, no * means match/pop with proof.

In this case, populate target 0, then 1, then 2, and poplate 3 with the first proof.

Then move up.  8 gets hashed from 0, 1.  We have the pointers to 0, 1 since nodes always come in pairs so a node's sibling will always be next to them in this list.
9 gets hashed from 2, 3.  These hashes are populated, since there's nothing in 8 or 9 yet.

12 gets hashed from 8, 9, and it's not populated, it's matched.  13 comes from the proof.

Since 12 matched and was the only * of this row, we're done.  We only need to keep going when there are * nodes that got populated.  If all * nodes matched, we can finish without further hashing.  (But maybe still populate the rest of the row with proofs.)

I'm not 100% sure this always works but feels like it does.

--------

Make moving / swapping nodes happen by changing the pointers of their parents, not by copying values
.. that might help with some of this?  Then if you tag a node as dirty, you don't care where it ends up; you have a pointer
to it and it will be hashed, regardless of where it does.
problem: how to deal with the tops / top slice.  When you swap with a top, there is no parent, so you can't change the 
parent.niece[x] pointer as there isn't one.  So you might have to have exceptions / different code for swapping to / from tops.
Since if you try like &topSlice[h] = n it says "cannot assign to &whatever"

move everything then hash everything.  Then you have "dirt" that is also subject to moves just like swapCollapses.
In fact the output from removeTransform can be all the swaps, and all the dirt post-swap; it does it all for you.
The downside here: you're going to descend each time you want to swap things.  But then you're going to descend again,
to the exact same things you just descended to, in order to hash them after all the swaps are done.  That seems pretty
ugly / lame.  Hmm.
